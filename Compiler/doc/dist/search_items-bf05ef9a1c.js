searchNodes=[{"ref":"CodeGenerator.html","title":"CodeGenerator","type":"module","doc":"Este modulo recibe un árbol ast y devuelve un string con el codigo ensamblador correspondiente."},{"ref":"CodeGenerator.html#generateCode/1","title":"CodeGenerator.generateCode/1","type":"function","doc":"Funcion que genera el código ensabmblador a partir de un nodo."},{"ref":"CodeGenerator.html#generateCodeNoP/1","title":"CodeGenerator.generateCodeNoP/1","type":"function","doc":"Funcion que regresa el codigo ensamblador sin imprimir el arbol."},{"ref":"CodeGenerator.html#getCode/4","title":"CodeGenerator.getCode/4","type":"function","doc":"Funcion que regresa el código ensamblador de program."},{"ref":"CodeGenerator.html#posorder/1","title":"CodeGenerator.posorder/1","type":"function","doc":"Funcion recursiva que recorre el arbol en pos orden y que regresa el codigo ensamblador. Parámetros -nodo : corresponde con el nodo actual y el que va a ser navegado."},{"ref":"CodeGenerator.html#pretty_printing/2","title":"CodeGenerator.pretty_printing/2","type":"function","doc":""},{"ref":"CodeGenerator.html#print_ast/2","title":"CodeGenerator.print_ast/2","type":"function","doc":""},{"ref":"Compiler.html","title":"Compiler","type":"module","doc":"Documentation for Compilador"},{"ref":"Compiler.html#compile_file/1","title":"Compiler.compile_file/1","type":"function","doc":""},{"ref":"Compiler.html#compile_optimization_l1/1","title":"Compiler.compile_optimization_l1/1","type":"function","doc":""},{"ref":"Compiler.html#compile_optimization_l2/1","title":"Compiler.compile_optimization_l2/1","type":"function","doc":""},{"ref":"Compiler.html#compiler_test/1","title":"Compiler.compiler_test/1","type":"function","doc":""},{"ref":"Compiler.html#main/1","title":"Compiler.main/1","type":"function","doc":""},{"ref":"Compiler.html#optimizer_test/1","title":"Compiler.optimizer_test/1","type":"function","doc":""},{"ref":"Compiler.html#print_token_list/1","title":"Compiler.print_token_list/1","type":"function","doc":""},{"ref":"Lexer.html","title":"Lexer","type":"module","doc":"Este modulo convierte un string a una lista de tokens para el proceso de compilacion de un archivo en C."},{"ref":"Lexer.html#check_spaces/2","title":"Lexer.check_spaces/2","type":"function","doc":"check_spaces Esta funcion revisa los espacios del string entrante y correspondiente a los tokens int y return para evitar errores como intmain o return2 Parámetros -token : Corresponde al token previamente reconocido. -sentence : Es el string sin el token reconocido."},{"ref":"Lexer.html#getTokens/1","title":"Lexer.getTokens/1","type":"function","doc":"getTokens Esta funcion recibe una tuplacon la sentencia y el numero de linea y regresa un error o una lista de tokens que reconocio. Parámetros -data : Tupla con el siguiente formato {linea,numero de linea} donde linea corresponde por ejemplo a int main() y linea es 2"},{"ref":"Lexer.html#lexer/1","title":"Lexer.lexer/1","type":"function","doc":"lexer Recibe el texto sin formato y devuelve una lista con tokens reconocidos. Es la funcion principal del Lexer. Parámetros -rawText : Corresponde con el texto que se obtiene de un archivo."},{"ref":"Lexer.html#sanitize/1","title":"Lexer.sanitize/1","type":"function","doc":"sanitize Elimina saltos de linea y obtiene la linea en la cual está. Parameters: rawText : Texto sin formatear."},{"ref":"Lexer.html#tokensRemaining/3","title":"Lexer.tokensRemaining/3","type":"function","doc":"def tokensRemaining Esta funcion sirve para agregar a una lista el token reconocido y posteriormente mandar de manera recursiva los otros elementos del string por ejemplo int main() reconoce int y manda a llamar a la funcion para que reconozca main() etc. Parametros: -data: Es el string entrante -token: Corresponde al token con el que se hizo match -char: Corresponde a la expresion regular para reemplazar con la cadena original"},{"ref":"Linker.html","title":"Linker","type":"module","doc":""},{"ref":"Linker.html#final/2","title":"Linker.final/2","type":"function","doc":""},{"ref":"Nodo.html","title":"Nodo","type":"module","doc":""},{"ref":"Nodo.html#t:nodo/0","title":"Nodo.nodo/0","type":"type","doc":""},{"ref":"Nodo.html#t:nodo/1","title":"Nodo.nodo/1","type":"type","doc":""},{"ref":"Optimizer.html","title":"Optimizer","type":"module","doc":"Este modulo recibe un árbol ast y devuelve un arbol ast optimizado o codigo ensamblador."},{"ref":"Optimizer.html#getCode/4","title":"Optimizer.getCode/4","type":"function","doc":""},{"ref":"Optimizer.html#o_posorder/1","title":"Optimizer.o_posorder/1","type":"function","doc":"Función que recorre el arbol y dependiendo de éste se optimizará o no. ##Parámetros -nodo : Nodo del ast que se va a optimizar"},{"ref":"Optimizer.html#optimizer_1/1","title":"Optimizer.optimizer_1/1","type":"function","doc":"Función que manda a llamar a la funcion correspondiente para realizar la optimizacion. ##Parámetros -nodo : Nodo del ast que se va a optimizar"},{"ref":"Optimizer.html#optimizer_2/1","title":"Optimizer.optimizer_2/1","type":"function","doc":"Función que manda a llamar a las funciones de optimizacion ##Parámetros -nodo : Nodo del ast que se va a optimizar"},{"ref":"Optimizer.html#optimizer_bitwiseN/3","title":"Optimizer.optimizer_bitwiseN/3","type":"function","doc":"Optimiza el bitwise negation en dado caso que sea posible. Reeplaza el nodo dado la siguiente regla: Si hay una expresion ~~5 regresará 5 y asi de manera ascendente en el árbol. ##Parámetros -ast_nodo : Se refiere al nodo actual -left : Hijo izquierdo del nodo actual optimizado o no. -right : Hijo derecho del nodo actual optimizado o no."},{"ref":"Optimizer.html#optimizer_log_neg/3","title":"Optimizer.optimizer_log_neg/3","type":"function","doc":"Optimiza la negacion lógica de tal manera que si encuentra tres negaciones seguidas se reducirá a una. Por ejemplo !!!5, esto primero dará 0, luego 1 y finalmente 0 por lo que es mas optimo solo utilizar una vez el !. Asimismo con numeros paresde negacion como: !!!!5 lo cual dara como resultado !!5. Si se cumple la condicion regresará el la expresion antes mencionada. Si no, entonces regresará un nodo con sus hijos left y right optimizados si asi sea. ##Parámetros -ast_nodo : Se refiere al nodo actual -left : Hijo izquierdo del nodo actual optimizado o no. -right : Hijo derecho del nodo actual optimizado o no."},{"ref":"Optimizer.html#optimizer_neg/3","title":"Optimizer.optimizer_neg/3","type":"function","doc":"Optimiza la negacion en dado caso que sea posible. Reeplaza el nodo dado la siguiente regla: Si hay una expresion --5 regresará 5 y asi de manera ascendente en el árbol. ##Parámetros -ast_nodo : Se refiere al nodo actual -left : Hijo izquierdo del nodo actual optimizado o no. -right : Hijo derecho del nodo actual optimizado o no."},{"ref":"Optimizer.html#posorder/1","title":"Optimizer.posorder/1","type":"function","doc":"Función que recorre el arbol y realizará todas las operaciones para regresar un único valor. ##Parámetros -nodo : Nodo del ast que se va a optimizar"},{"ref":"Parser.html","title":"Parser","type":"module","doc":"Este modulo recibe una lista de tokens y regresa un arbol ast con la gramatica: ::= ::= \"int\" \"(\" \")\" \"{\" \"}\" ::= \"return\" \";\" ::= { \"||\" } ::= { \"&&\" } ::= { (\"!=\" | \"==\") } ::= { (\"\" | \"=\") } ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= \"(\" \")\" | | ::= \"!\" | \"~\" | \"-\""},{"ref":"Parser.html#check_unary_op/1","title":"Parser.check_unary_op/1","type":"function","doc":"Funcion que recibe un atomo de un token y revuelve True o False si es que es un operador unario"},{"ref":"Parser.html#parseAdditiveExp/1","title":"Parser.parseAdditiveExp/1","type":"function","doc":"Corresponde a la funcion que hace el parse de additive exp"},{"ref":"Parser.html#parseEqualityExp/1","title":"Parser.parseEqualityExp/1","type":"function","doc":"Corresponde a la funcion que hace el parse de equality exp"},{"ref":"Parser.html#parseExp/1","title":"Parser.parseExp/1","type":"function","doc":"Corresponde a la funcion que hace el parse de expression"},{"ref":"Parser.html#parseFactor/1","title":"Parser.parseFactor/1","type":"function","doc":"Corresponde a la funcion que hace el parse de factor"},{"ref":"Parser.html#parseFunction/1","title":"Parser.parseFunction/1","type":"function","doc":"Corresponde a la funcion que hace el parse de Function"},{"ref":"Parser.html#parseLogicalAndExp/1","title":"Parser.parseLogicalAndExp/1","type":"function","doc":"Corresponde a la funcion que hace el parse de logical and exp"},{"ref":"Parser.html#parseProgram/1","title":"Parser.parseProgram/1","type":"function","doc":"Corresponde a la funcion que hace el parse de program"},{"ref":"Parser.html#parseRelationalExp/1","title":"Parser.parseRelationalExp/1","type":"function","doc":"Corresponde a la funcion que hace el parse de relational exp"},{"ref":"Parser.html#parseStatement/1","title":"Parser.parseStatement/1","type":"function","doc":"Corresponde a la funcion que hace el parse de statement"},{"ref":"Parser.html#parseTerm/1","title":"Parser.parseTerm/1","type":"function","doc":"Corresponde a la funcion que hace el parse de term"},{"ref":"Parser.html#while_parse/4","title":"Parser.while_parse/4","type":"function","doc":"Esta funcion hace el papel de un while recursivo el cual dependiendo de los parametros va a hacer una busqueda hacia adelante en busca de mas expresiones del tipo de los parámetros y como se indica en la gramática. Parámetros -tokens : Corresponde a la lista de tokens reconocidos en procesos previos como el lexer. -term : Corresponde a una parte del arbol ast para añadir mas elementos al arbol como padre. -list : Corresponde a la lista de tokens en la que debe de estar el siguiente token a ser evaluado. -function : Corresponde a la funcion que se va a evaluar recursivamente."},{"ref":"Token.html","title":"Token","type":"module","doc":"Este módulo es para definir los tokens que se van a utilizar en todo el proceso."},{"ref":"Token.html#addition/1","title":"Token.addition/1","type":"function","doc":""},{"ref":"Token.html#andT/1","title":"Token.andT/1","type":"function","doc":""},{"ref":"Token.html#assignment/1","title":"Token.assignment/1","type":"function","doc":""},{"ref":"Token.html#bitwiseN/1","title":"Token.bitwiseN/1","type":"function","doc":""},{"ref":"Token.html#closeBrace/1","title":"Token.closeBrace/1","type":"function","doc":""},{"ref":"Token.html#closeParen/1","title":"Token.closeParen/1","type":"function","doc":""},{"ref":"Token.html#constant/2","title":"Token.constant/2","type":"function","doc":""},{"ref":"Token.html#division/1","title":"Token.division/1","type":"function","doc":""},{"ref":"Token.html#equal/1","title":"Token.equal/1","type":"function","doc":""},{"ref":"Token.html#greaterThan/1","title":"Token.greaterThan/1","type":"function","doc":""},{"ref":"Token.html#greaterThanEq/1","title":"Token.greaterThanEq/1","type":"function","doc":""},{"ref":"Token.html#identifier/2","title":"Token.identifier/2","type":"function","doc":""},{"ref":"Token.html#intKeyword/1","title":"Token.intKeyword/1","type":"function","doc":""},{"ref":"Token.html#lessThan/1","title":"Token.lessThan/1","type":"function","doc":""},{"ref":"Token.html#lessThanEq/1","title":"Token.lessThanEq/1","type":"function","doc":""},{"ref":"Token.html#logicalN/1","title":"Token.logicalN/1","type":"function","doc":""},{"ref":"Token.html#multiplication/1","title":"Token.multiplication/1","type":"function","doc":""},{"ref":"Token.html#negation_minus/1","title":"Token.negation_minus/1","type":"function","doc":""},{"ref":"Token.html#notEqual/1","title":"Token.notEqual/1","type":"function","doc":""},{"ref":"Token.html#openBrace/1","title":"Token.openBrace/1","type":"function","doc":""},{"ref":"Token.html#openParen/1","title":"Token.openParen/1","type":"function","doc":"Define los tokens que se van a utilizar dando un entero que se refiere a la linea donde se encuentra dicha expresion para ser utilizada posteriormente} en el manejo de errores."},{"ref":"Token.html#orT/1","title":"Token.orT/1","type":"function","doc":""},{"ref":"Token.html#returnKeyword/1","title":"Token.returnKeyword/1","type":"function","doc":""},{"ref":"Token.html#semicolon/1","title":"Token.semicolon/1","type":"function","doc":""},{"ref":"Token.html#t:token/0","title":"Token.token/0","type":"type","doc":""}]